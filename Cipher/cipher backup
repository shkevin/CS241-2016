/* ************************************
* Kevin Cox
*
* Reads in file one bit at a time,
* encrypts or decrypts that bit as 
* specified by the file read in.
************************************ */

#include <stdio.h>
#include "lcg.h"
#include <ctype.h>
#include <stdlib.h>

#define IN 1
#define OUT 0
#define ERROR -1
#define NEWPROBLEM 2

void encrypt(char c);
void decrypt(char c);
int determineCipher(char c);
int readInLine(char c, int mode);
int skipLine();
int readToDelimeter(char c, char delimeter);
void incrementC(char c, int increment);

enum cipher{ENCRYPT, DECRYPT}; /*enum to toggle ciphermode*/
enum cipher ciphermode; /*value to determine encryption or decryption*/
char data[10]; /*array to store data to be encrypted or decrypted*/
int commaCount, index; /*counts commas, index used to increment in data*/
struct LinearCongruentialGenerator MyStruct; /*struct used to store lcg*/
unsigned long lcg_m, lcg_c, lcg_a, lcg_x; /*modulus m, increment c, equation a, seed x*/

int main()
{	
	int c, nextAction, mode;;
	c = nextAction = mode = commaCount = index = 0;
	lcg_m = lcg_c = lcg_a = lcg_x = 0;

	while((c = getchar()) != EOF)
	{
		mode = determineCipher(c); /* determines cipher based on action*/
		printf("%c", c);
		if(mode == ERROR)
		{
			/* have error, skip to end of line*/
			skipLine();
			mode = NEWPROBLEM;
			commaCount = index = 0;
		}
		else if (mode == OUT)
		{	
			mode = IN;
		}
		else if(mode == NEWPROBLEM)
		{
			/*reset bookeeping*/
			commaCount = index = 0;
			printf("\n");
			break;
		}
		if(mode == IN)
		{
			while(mode == IN) /*read in data here*/
			{
				/*this is where the magic happens*/
				mode = readInLine(c, mode);
				break;
			}
		}
	}
	return 0;
}

/***************************************************************/
/* Helper fucntion to read in each line and determine validity */
/* Parameters: character of file read in 					   */
/* returns: if valid line 									   */
/***************************************************************/
int determineCipher(char c)
{	
	int mode;
	if (c == '\n')
	{
		return NEWPROBLEM;
	}
	if (c == ',')
	{
		commaCount++;
		return mode = OUT;
	}

	if ((c == 'e') && (commaCount == 0))
	{
		ciphermode = ENCRYPT;
		return IN;
	}
	else if ((c == 'd') && (commaCount == 0))
	{
		ciphermode = DECRYPT;
		return IN;
	}
	return ERROR;
}

/***************************************************************/
/* Function: */
/* Parameters: */
/* returns: */
/*                        									   */
/***************************************************************/
int readInLine(char c, int mode)
{
	if (c == '\n')
	{
		return mode = NEWPROBLEM;
	}
	if (c == ',')
	{
		return mode = OUT;
	}

	if (commaCount == 0)
	{
		/* read in lcg m, error if !isdigit()*/
		if (isdigit(c - '0'))
		{
			lcg_m = readToDelimeter(c, ',');
			printf("%lu", lcg_m);
		}
		else
		{
			mode = ERROR;
		}
	}
	else if (commaCount == 1)
	{
		/* read in lcg c, error if !isdigit()*/
		if (isdigit(c - '0'))
		{
			lcg_c = readToDelimeter(c, ',');
			printf("%lu", lcg_c);
			MyStruct = makeLCG(lcg_m, lcg_c);
		}
		else
		{
			mode = ERROR;
		}
	}
	else if (commaCount == 2)
	{
		if (ciphermode == ENCRYPT)
		{
			/*read in data here, then e or d, error if not in range 
			of ascii characters 32-126*/
			while(c != '\n')
			{
				encrypt(c);
			}
			mode = NEWPROBLEM;
		}
		else if (ciphermode == DECRYPT)
		{
			while(c != '\n')
			{
				decrypt(c);
			}
			mode = NEWPROBLEM;
		}
		else
		{
			mode = ERROR;
		}
	}
	return mode;
}

int readToDelimeter(char c, char delimeter)
{
	char* endPt;
	while(c != delimeter)
	{	
		if (commaCount == 0)
		{
			/*read lcg m*/
			data[index] = c;
		}
		else
		{
			/*read lcg c*/
			data[index] = c;
		}
		index++;
		c = getchar();
	}
	data[index] = '\0';
	return strtoul(data, &endPt, 10);
}

unsigned long modOrIncrement;
	int index = 0;
	char c = getchar();
	index = 0;
	while(c != delimeter)
	{	
		if (commaCount == 0)
		{
			/*read lcg m*/
			lcgm[index] = c;
		}
		else 
		{
			/*read lcg c*/
			lcgc[index] = c;
		}
		index++;
		c = getchar();
	}
	if (commaCount == 0)
	{
		modOrIncrement = strtoul(lcgm, NULL, 10);
	}
	else if(commaCount == 1)
	{
		modOrIncrement = strtoul(lcgc, NULL, 10);
	}
	return modOrIncrement;
}

/***************************************************************/
/* Function: */
/* Parameters: */
/* returns: */
/*                        									   */
/***************************************************************/
void encrypt(char c)
{
	printf("encrypting: %c", c);
}

/***************************************************************/
/* Function: */
/* Parameters: */
/* returns: */
/*                        									   */
/***************************************************************/
void decrypt(char c)
{
	/*need to remember previous char as well*/
	printf("decrypting: %c", c);
}

/***************************************************************/
/* helper function used to skip to end of line if error 	   */
/* Parameters: none											   */
/* returns: none 											   */
/***************************************************************/
int skipLine()
{	
	int mode;
	char c;
	while(c != '\n' && c != EOF)
	{
		c = getchar();
	}
	if(c == EOF) mode = EOF;/*break proram*/
	return mode;
}

void incrementC(char c, int increment)
{
	int i;
	for (i = 0; i <= increment; ++i)
	{
		c = getchar();
		printf("incrementing c: %c", c);
	}
}
